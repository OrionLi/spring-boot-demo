# Demo03 批量消费

在一些业务场景下，我们希望使用 消费者 批量消费消息，提高消费速度。要注意，消费者 的批量消费消息，和 批量发送消息 没有直接关联

# 配置

和 Demo 02 的消费者相比，方法上的参数变成了 List 数组

相比 Demo1 `kafka-quick-start`，本模块配置多了：

- `spring.kafka.listener.type`：表示消息监听器类型，有两种可选项：
    - 记录监听器（Record Listener）：默认值，其会在每次接收到单个消息时触发一次消费逻辑。
    - 批处理监听器（Batch Listener）：会将多条消息放到一个列表中后再进行处理，这样可以减少消耗的资源和提高消费者端的吞吐量。
- `spring.kafka.consumer.max-poll-records`：表示每次调用 `poll()` 方法最多获取的消息数量，默认为 500 条消息。该参数与 Kafka
  消息拉取机制相关，即尝试从 Broker 中拉取最多指定数量的消息，以便在消费者端异步地提交确认请求；如果此处设置的值较大，则可能导致消费端内存占用过高或消费不及时，从而影响系统性能。
- `spring.kafka.consumer.fetch-min-size`：表示每次检索操作至少要拉取的字节数，默认值为 1 字节。如果 Broker
  端中没有足够大小的消息，则消费者端的轮询流程会等待更多的消息到来或者达到设定的超时阈值。
- `spring.kafka.consumer.fetch-max-wait`：表示等待消息的最长时间间隔，默认为 500 毫秒。该参数是控制轮询动作阻塞时间的关键点，当
  Broker 端没有新消息极力推送到消费者端时，轮询动作将会阻塞至多等待超出此处所配置的最长时间后才返回已有缓存消息进行消费。

# 测试结果

从日志中，我们可以看出，发送的 3 条消息被 `Demo03Consumer` 批量消费了

为了更好地做对比，可以尝试把配置改成 `spring.kafka.listener.type=SINGLE` ，就会发现 `Demo03Consumer` 只会单条消费了
> 监听器类型默认为 SINGLE ，只监听单条消息。这里我们配置 BATCH ，监听多条消息，批量消费
